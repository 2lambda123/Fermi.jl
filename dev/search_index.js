var documenterSearchIndex = {"docs":
[{"location":"backend/#Backend","page":"Backend","title":"Backend","text":"","category":"section"},{"location":"mp/#Møller-Plesset","page":"Møller-Plesset","title":"Møller-Plesset","text":"","category":"section"},{"location":"mp/#MP2","page":"Møller-Plesset","title":"MP2","text":"","category":"section"},{"location":"mp/","page":"Møller-Plesset","title":"Møller-Plesset","text":"Fermi.MollerPlesset.RMP2","category":"page"},{"location":"mp/#Fermi.MollerPlesset.RMP2","page":"Møller-Plesset","title":"Fermi.MollerPlesset.RMP2","text":"Fermi.MollerPlesset.RMP2\n\nWave function object for Second Order Restricted Moller-Plesset methods.\n\nHigh Level Interface\n\nRun a RMP2 computation and return the RMP2 object:\n\njulia> @energy rmp2\n\nEquivalent to\n\njulia> Fermi.MollerPlesset.RMP2()\n\nThis function calls a constructor that runs a MP2 computation based on the options found in Fermi.Options.\n\nFields\n\nName Description\ncorrelation Computed RMP2 correlation energy\nenergy Total wave function energy (Reference energy + Correlation energy)\n\nRelevant options\n\nThese options can be set with @set <option> <value>\n\nOption What it does Type choices [default]\nmp2_alg Picks MP2 algorithm Int [1]\nbasis What basis set to use String [\"sto-3g\"]\ndf Whether to use density fitting Bool true [false]\nrifit What aux. basis set to use for RI String [\"auto\"]\ndrop_occ Number of occupied electrons to be dropped Int [0]\ndrop_vir Number of virtual electrons to be dropped Int [0]\n\n\n\n\n\n","category":"type"},{"location":"hartreefock/#Hartree-Fock","page":"Hartree-Fock","title":"Hartree-Fock","text":"","category":"section"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"The Hartree-Fock method is one of simplest ab initio methods where the wave function is modeled as a single Slater determinant of spin-orbitals","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"Psi_textHF(12N) = frac1sqrtN left \nbeginarrayc c c c\nphi_1(1)  phi_2(1)    phi_N(1) \nphi_1(2)  phi_2(2)    phi_N(2) \nvdots  vdots  ddots  vdots \nphi_1(N)  phi_2(N)    phi_N(N) \nendarrayright","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"The spin-orbitals are constructed under the basis set approximation","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"phi_i(vecr) = C_mu i chi_mu(vecr)","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"Note that sum over repeated indices is assumed.","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"where chi(vecr) are contracted Gaussian basis functions from pre-constructed basis set such as STO-3G, cc-pVDZ, ANO, etc. ","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"These orbitals are constrained to be orthonormal to each other. Moreover, we choose to solve for the set of orbitals that diagonalize the Fock matrix","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"D^alpha_mu nu = C^alpha_mu i C^alpha_nu i 2mm\nF^alpha_mu nu = H_mu nu + (D^alpha_lambdasigma + D^beta_lambdasigma)(mu nu  lambda sigma) + D^alpha_lambdasigma(mu nu  lambda sigma)","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"such that","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"C^alpha_mu i F^alpha_munu C^alpha_nu j = delta_ij epsilon_i","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"These are the canonical Hartree-Fock orbitals. ","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"Equations also need to be solved for F^beta, but in the case of a restricted calculation, i.e. orbitals for both spins are taken to be the same, solving for beta will yield the same results as for alpha.","category":"page"},{"location":"hartreefock/#Restricted-Hartree-Fock-(RHF)","page":"Hartree-Fock","title":"Restricted Hartree-Fock (RHF)","text":"","category":"section"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"Minimal example","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"using Fermi\n\n@molecule {\n    He 0.0 0.0 0.0\n}\n\n@set basis 3-21g\n@energy rhf","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"This will run a RHF computation on Helium using the 3-21G basis set. Currently, Fermi does not support point group symmetry.","category":"page"},{"location":"hartreefock/#Output-file","page":"Hartree-Fock","title":"Output file","text":"","category":"section"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"The first part of the output gives an overview of the input information","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"He    0.000000000000    0.000000000000    0.000000000000\n\n\nCharge: 0   Multiplicity: 1   \nNuclear repulsion:    0.0000000000\n Number of AOs:                            2\n Number of Doubly Occupied Orbitals:       1\n Number of Virtual Spatial Orbitals:       1","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"First the molecule XYZ is print. Followed by charge and multiplicity. Those will be taken as 0 and 1 by default, but can be controlled using @set charge and @set multiplicity. ","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"⚠️ RHF can only be used if the multiplicity is 1.","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"Next, we see the information about the iterations","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":" Iter.            E[RHF]         ΔE       Dᵣₘₛ        t     DIIS     damp\n--------------------------------------------------------------------------------\n    1     -2.8352184971  -2.835e+00   1.166e-01     0.78    false     4.71\n    2     -2.8260289197   9.190e-03   2.885e-02     0.00    false     1.45\n    3     -2.8157915919   1.024e-02   1.601e-02     0.00    false     0.00\n    4     -2.8355956172  -1.980e-02   4.948e-02     0.18     true     0.00\n    5     -2.8356798736  -8.426e-05   3.475e-03     0.00     true     0.00\n    6     -2.8356798733   2.662e-10   8.346e-06     0.00     true     0.00\n    7     -2.8356798736  -2.908e-10   6.418e-06     0.00     true     0.00\n    8     -2.8356798736  -1.554e-14   4.527e-08     0.00     true     0.00\n    9     -2.8356798728   8.546e-10   1.108e-05     0.14     true     0.00\n    10    -2.8356798735  -7.070e-10   6.475e-06     0.00     true     0.00\n    11    -2.8356798736  -1.477e-10   4.596e-06     0.00     true     0.00\n    12    -2.8356798736  -8.882e-16   9.630e-09     0.00     true     0.00\n    13    -2.8356798736   4.441e-16   1.687e-10     0.00     true     0.00\n--------------------------------------------------------------------------------\n RHF done in  1.46s","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"Iterations are controlled using a few keywords. The convergence is achieved when","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"The number of iterations reaches scf_max_iter","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"or","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"Delta E is less than scf_e_conv and D_rms is less than scf_max_rms","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"DIIS and damp are auxiliary strategies to reach convergency faster. ","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"Finally, the RHF energy is listed along with orbital energies","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"    @Final RHF Energy          -2.835679873641 Eₕ\n\n   • Orbitals Summary\n\n    Orbital            Energy    Occupancy\n          1     -0.9035715084       ↿⇂\n          2      2.0817026436         \n\n   ✔  SCF Equations converged 😄","category":"page"},{"location":"hartreefock/#RHF-object","page":"Hartree-Fock","title":"RHF object","text":"","category":"section"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"The computation returns a wave function object Fermi.HartreeFock.RHF which contains data useful for post-processing.","category":"page"},{"location":"hartreefock/","page":"Hartree-Fock","title":"Hartree-Fock","text":"Fermi.HartreeFock.RHF","category":"page"},{"location":"hartreefock/#Fermi.HartreeFock.RHF","page":"Hartree-Fock","title":"Fermi.HartreeFock.RHF","text":"Fermi.HartreeFock.RHF\n\nWave function object for Restricted Hartree-Fock methods\n\nHigh Level Interface\n\nRun a RHF computation and return the RHF object:\n\njulia> @energy rhf\n\nEquivalent to\n\njulia> Fermi.HartreeFock.RHF()\n\nComputes RHF using information from Fermi.Options.Current\n\nFields\n\nName Description\nmolecule Molecule object\nenergy RHF Energy\nndocc Number of doubly occupied spatial orbitals\nnvir Number of virtual spatial orbitals\norbitals RHF Orbitals object\ne_conv ΔE from the last iteration\nd_conv Orbitals RMS change from the last iteration\n\nRelevant options\n\nThese options can be set with @set <option> <value>\n\nOption What it does Type choices [default]\nrhf_alg Picks RHF algorithm Int [1]\nscf_max_rms RMS density convergence criterion Float64 [10^-9]\nscf_max_iter Max number of iterations Int [50]\nscf_e_conv Energy convergence criterion Float64 [10^-10]\nbasis What basis set to use String [\"sto-3g\"]\ndf Whether to use density fitting Bool true [false]\njkfit What aux. basis set to use for JK String [\"auto\"]\ndiis Whether to use DIIS Bool [true] false\noda Whether to use ODA Bool [true] false\noda_cutoff When to turn ODA off (RMS) Float64 [1E-1]\noda_shutoff When to turn ODA off (iter) Int [20]\nscf_guess Which guess density to use String \"core\" [\"gwh\"]\n\nStruct tree\n\nRHF <: AbstractHFWavefunction <: AbstractWavefunction\n\n\n\n\n\n","category":"type"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"cc/#Coupled-Cluster","page":"Coupled Cluster","title":"Coupled Cluster","text":"","category":"section"},{"location":"cc/#CCSD","page":"Coupled Cluster","title":"CCSD","text":"","category":"section"},{"location":"cc/","page":"Coupled Cluster","title":"Coupled Cluster","text":"Fermi.CoupledCluster.RCCSD","category":"page"},{"location":"cc/#Fermi.CoupledCluster.RCCSD","page":"Coupled Cluster","title":"Fermi.CoupledCluster.RCCSD","text":"Fermi.CoupledCluster.RCCSD\n\nWave function object for Restricted Coupled Cluster Singles and Doubles.\n\nHigh Level Interface\n\nRun a RCCSD computation and return the RCCSD object:\n\njulia> @energy rccsd \n\nEquivalent to\n\njulia> Fermi.CoupledCluster.RCCSD()\n\nThis function calls a constructor that runs a RCCSD computation based on the options found in Fermi.Options.\n\nFields\n\nName Description\nguessenergy Energy recovered in the first iteration, normally RMP2\ncorrelation Computed RCCSD correlation energy\nenergy Total wave function energy (Reference energy + Correlation energy)\ne_conv ΔE from the last iteration\nt_conv Amplitudes RMS change from the last iteration\n\nRelevant options\n\nThese options can be set with @set <option> <value>\n\nOption What it does Type choices [default]\ncc_alg Picks RCCSD algorithm Int [1]\ncc_e_conv Energy convergence criterion Float64 [10^-10]\ncc_max_rms Amplitudes RMS convergence criterion Float64 [10^-10]\ncc_max_iter Max number of CC iterations Int [50]\ncc_damp_ratio Fraction of old amplitudes to be kept Float64 0.0–1.0 [0.0]\ncc_diis Whether to use DIIS Bool false [true]\ndiis_start Iteration number where DIIS starts Int [3]\ncc_diis_relax Interval between DIIS extrapolations Int [3]\ncc_ndiis Maximum number of stored vectors for DIIS Int [3]\nbasis What basis set to use String [\"sto-3g\"]\ndf Whether to use density fitting Bool true [false]\nrifit What aux. basis set to use for RI String [\"auto\"]\ndrop_occ Number of occupied electrons to be dropped Int [0]\ndrop_vir Number of virtual electrons to be dropped Int [0]\n\n\n\n\n\n","category":"type"},{"location":"cc/#CCSD(T)","page":"Coupled Cluster","title":"CCSD(T)","text":"","category":"section"},{"location":"cc/","page":"Coupled Cluster","title":"Coupled Cluster","text":"Fermi.CoupledCluster.RCCSDpT","category":"page"},{"location":"cc/#Fermi.CoupledCluster.RCCSDpT","page":"Coupled Cluster","title":"Fermi.CoupledCluster.RCCSDpT","text":"Fermi.CoupledCluster.RCCSDpT\n\nFermi struct that holds information about RCCSD(T) wavefunctions\n\nstruct tree:\n\nRCCSD(T) <: AbstractCCWavefunction <: AbstractCorrelatedWavefunction <: AbstractWavefunction\n\n\n\n\n\n","category":"type"},{"location":"indice/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"indice/","page":"Index","title":"Index","text":"Below is the list of types and functions mentioned in the documentation.","category":"page"},{"location":"indice/#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"indice/","page":"Index","title":"Index","text":"Order = [:type]","category":"page"},{"location":"indice/#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"indice/","page":"Index","title":"Index","text":"Order = [:function]","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"#Fermi.jl","page":"Basics","title":"Fermi.jl","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"Fermi is Julia framework for ab initio quantum chemistry. The main goal of Fermi is to offer two key resources:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"A collection of standard methods in electronic structure theory, such as Hartree–Fock and Coupled Cluster.\nAn efficient development platform for quantum chemistry methods.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"📝 For an academic overview of the project, check our paper published at the Journal of Chemical Theory and Computation:","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Fermi.jl: A Modern Design for Quantum Chemistry","category":"page"},{"location":"#Installation","page":"Basics","title":"Installation","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"Fermi is a registered Julia package and, as such, it can be obtained using the standard Julia package manager. From the Julia terminal, use the ] to move to the pkg manager","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"julia> # This is the standard Julia terminal, hit ] to go into Pkg\n(@v1.6) pkg> # This is the package manager! Hit back space to leave this mode","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Next add Fermi to the current environment.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"(@v1.6) pkg> add Fermi","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"All the dependencies are going to be downloaded and installed and the code should be ready to work. To test the package you can run","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"(@v1.6) pkg> test Fermi","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"If you want a version of Fermi that you can modify, clone and check it for development","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"shell> git clone https://github.com/FermiQC/Fermi.jl\nshell> cd Fermi.jl\n(@v1.6) pkg> dev .","category":"page"},{"location":"#Usage","page":"Basics","title":"Usage","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"Fermi can be used interactively through the Julia terminal, or you can write a Julia script which will act as the traditional input file present in other quantum chemistry packages. For example, a minimal script to run a RHF computation on a water molecule can be written as","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"using Fermi\n\n@molecule {\n  O        1.2091536548      1.7664118189     -0.0171613972\n  H        2.1984800075      1.7977100627      0.0121161719\n  H        0.9197881882      2.4580185570      0.6297938830\n}\n\n@set basis sto-3g\n@energy rhf","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"If you save this file as input.jl, you can run it as a regular script","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"shell> julia --threads N input.jl","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"where N is the desired number of threads. Alternatively, you can set export JULIA_NUM_THREADS=N in your path.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Multiple options can be set using the macro @set with curly braces","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"@set {\n  basis cc-pvdz\n  df true\n  jkfit cc-pvtz-jkfit\n}","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"The macro @energy returns a wave function object associated with the methods requested. See the documentation for each method for more details.","category":"page"},{"location":"#Output","page":"Basics","title":"Output","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"Results of computations are returned to the REPL terminal by default. This can be controlled with the keywords printstyle and output.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"output contains the name of the file where results will be written. The default is fermi.out\nprintstyle accepts four options","category":"page"},{"location":"","page":"Basics","title":"Basics","text":" \nrepl Print results to the REPL terminal\nfile Print results to the file specified with the keyword output\nboth Print results to the REPL and write it to the file specified with the keyword output\nnone Does not print any results","category":"page"},{"location":"#Argument-passing","page":"Basics","title":"Argument passing","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"In some situations, we may want to pass argument to the energy computation. There are two ways to do that in Fermi. ","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Call the function directly, without using macros.\nUse the => or <= syntax within the @energy macro.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"The code shown below computes a potential energy curve for the Helium dimer. First using functions directly","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"using Fermi\nRvals = [1.0 + 0.1*i for i = 0:10]\nE = []\nfor r in Rvals\n    mol = Molecule(molstring = \"\"\"\n        He 0.0 0.0 0.0\n        He $r  0.0 0.0\"\"\")\n    wfn = Fermi.MollerPlesset.RMP2(mol)\n    push!(E, wfn.energy)\nend","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Now using the @energy macro","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"using Fermi\nRvals = [1.0 + 0.1*i for i = 0:10]\nE = []\nfor r in Rvals\n    mol = Molecule(molstring = \"\"\"\n        He 0.0 0.0 0.0\n        He $r  0.0 0.0\"\"\")\n    wfn = @energy mol => mp2\n    push!(E, wfn.energy)\nend","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"@energy x,y,z,... => mp2 is equivalent to Fermi.MollerPlesset.RMP2(x,y,z,...)","category":"page"},{"location":"#Interactive-Usage","page":"Basics","title":"Interactive Usage","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"Interactive usage may be your best option for quick tasks, debugging, or if you are simply browsing the code. Moreover, this feature allows for usage within notebook environments such as Jupyter and Pluto. Some objects, such as Molecule, BasisSet or RHF, can be printed directly on the terminal for some overview of their content.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"julia> using Fermi\njulia> using Fermi.Integrals\n\njulia> mol = Molecule()\nMolecule:\n\nO    1.209153654800    1.766411818900   -0.017161397200\nH    2.198480007500    1.797710062700    0.012116171900\nH    0.919788188200    2.458018557000    0.629793883200\n\n\nCharge: 0   Multiplicity: 1   \nNuclear repulsion:    8.8880641737\n\njulia> BasisSet(\"sto-3g\", mol)\nsto-3g Basis Set\nNumber of shells: 5\nNumber of basis:  7\n\nO: 1s 2s 1p \nH: 1s \nH: 1s\n\njulia> @set printstyle none;\njulia> wfn = @energy rhf\n ⇒ Fermi Restricted Hartree--Fock Wave function\n ⋅ Basis:                  sto-3g\n ⋅ Energy:                 -74.965002894685\n ⋅ Occ. Spatial Orbitals:  5\n ⋅ Vir. Spatial Orbitals:  2\nConvergence: ΔE => 0.00e+00 Dᵣₘₛ => 2.00e-10","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"While using Fermi interactively, one can use the macro @get to check the current value of an option keyword","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"julia> @set basis 6-31g\njulia> @get basis\n\"6-31g\"","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"or it can be used without arguments to check all user defined keywords","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"julia> @set {\n  basis 6-31g\n  df false\n  diis false\n}\njulia> @get\n┌─────────┬───────────────┐\n│ Keyword │ Current Value │\n├─────────┼───────────────┤\n│    diis │         false │\n│      df │         false │\n│   basis │         6-31g │\n└─────────┴───────────────┘","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"The macro @reset erases all options set","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"julia> @reset\njulia> @get\nNo user defined keywords found.","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Finally, the macro @lookup offers a quick way to look up keywords","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"julia> @lookup scf\n┌──────────────┬───────────────┐\n│      Keyword │ Current Value │\n├──────────────┼───────────────┤\n│  scf_max_rms │   1.00000e-09 │\n│ scf_max_iter │            50 │\n│    scf_guess │           gwh │\n│      scf_alg │             1 │\n│   scf_e_conv │   1.00000e-10 │\n└──────────────┴───────────────┘","category":"page"},{"location":"#Available-methods","page":"Basics","title":"Available methods","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"The following methods are currently implemented in Fermi","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Method Conventional Density-Fitted Single Precision\nRHF ✔️ ✔️ ✖️\nUHF ✔️ ✔️ ✖️\nRMP2 ✔️ ✔️ ✔️\nRCCSD ✔️ ✔️ ✔️\nRCCSD(T) ✔️ ✔️ ✔️","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Only restricted reference methods are currently supported for correlated methods. All methods can use density fitting by setting @set df true. Moreover, JKFIT and RIFIT basis can be specified as","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"@set {\n    jkfit cc-pvqz-jkfit\n    rifit cc-pvqz-rifit\n}","category":"page"},{"location":"","page":"Basics","title":"Basics","text":"Single precision calculations are also possible using @set precision single.","category":"page"},{"location":"#About","page":"Basics","title":"About","text":"","category":"section"},{"location":"","page":"Basics","title":"Basics","text":"Fermi.jl is developed at the Center for Computational Quantum Chemistry at the University of Georgia under the supervision  of Dr. Justin M. Turney and Prof. Henry F. Schaefer. For any questions, suggestions or if you want to participate in this project, please email Gustavo Aroeira (aroeira at uga.edu).","category":"page"},{"location":"modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Fermi has a number of submodules organized for specific tasks. All modules are accessed as Fermi.ModuleName.","category":"page"},{"location":"modules/#Options","page":"Modules","title":"Options","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Fermi.Options","category":"page"},{"location":"modules/#Fermi.Options","page":"Modules","title":"Fermi.Options","text":"Fermi.Options\n\nModule to manage options in Fermi. \n\nFunctions\n\nFermi.Options.set(option, value)     Set an <option> to a given <value>\nFermi.Options.get(option)            Return the current value of an <option>\nFermi.Options.reset()                Reset all options to default values\nFermi.Options.reset(option)          Reset a specific <option> to its default value\nFermi.Options.molecule(molstring)    Read in a String for the `molstring` option\n\nAlternatively, at global scope, one can use the corresponding macros that create shortcuts for the commands above\n\nMacros\n\n@set <option> <value>   Set an <option> to a given <value>\n@get <option>           Return the current value of an <option>\n@reset                  Reset all options to default values\n@reset <option>         Reset a specific <option> to its default value\n@molecule               Read in a String for the `molstring` option\n@lookup <string>        Search for keywords containing <string>\n\n\n\n\n\n","category":"module"},{"location":"modules/#DIIS","page":"Modules","title":"DIIS","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Fermi.DIIS","category":"page"},{"location":"modules/#PhysicalConstants","page":"Modules","title":"PhysicalConstants","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Fermi.PhysicalConstants","category":"page"},{"location":"modules/#Fermi.PhysicalConstants","page":"Modules","title":"Fermi.PhysicalConstants","text":"Fermi.PhysicalConstants\n\nModule for storing physical constants and conversion factors used in computations.\n\nFunctions:\n\natomic_number   Given an element symbol, return the atomic number.\n\n\n\n\n\n","category":"module"},{"location":"modules/#Orbitals","page":"Modules","title":"Orbitals","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Fermi.Orbitals","category":"page"},{"location":"modules/#Integrals","page":"Modules","title":"Integrals","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Fermi.Integrals","category":"page"},{"location":"modules/#Fermi.Integrals","page":"Modules","title":"Fermi.Integrals","text":"Fermi.Integrals\n\nModule to compute and manage molecular integrals.\n\n\n\n\n\n","category":"module"},{"location":"modules/#HartreeFock","page":"Modules","title":"HartreeFock","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Fermi.HartreeFock","category":"page"},{"location":"modules/#Fermi.HartreeFock","page":"Modules","title":"Fermi.HartreeFock","text":"Fermi.HartreeFock\n\nModule for running Hartree–Fock computations in Fermi.\n\nMethods\n\n> Fermi.HartreeFock.RHF\n> Fermi.HartreeFock.UHF\n\n\n\n\n\n","category":"module"},{"location":"modules/#MollerPlesset","page":"Modules","title":"MollerPlesset","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Fermi.MollerPlesset","category":"page"},{"location":"modules/#Fermi.MollerPlesset","page":"Modules","title":"Fermi.MollerPlesset","text":"Fermi.MøllerPlesset\n\nModule for running Møller–Plesset perturbation theory computations.\n\n\n\n\n\n","category":"module"},{"location":"modules/#CoupledCluster","page":"Modules","title":"CoupledCluster","text":"","category":"section"},{"location":"modules/","page":"Modules","title":"Modules","text":"Fermi.CoupledCluster","category":"page"},{"location":"modules/#Fermi.CoupledCluster","page":"Modules","title":"Fermi.CoupledCluster","text":"Fermi.CoupledCluster\n\nModule for running CoupledCluster computations in Fermi.\n\n\n\n\n\n","category":"module"}]
}
